{
  "name": "Quick-grid",
  "tagline": "Dotnet helper classes for querying and and angular front end directives",
  "body": "# Quick Grid\r\n\r\n## Installation\r\n\r\n### Bower\r\nTo add support to your angular application install the bower package\r\n```\r\nbower install ng-quick-grid\r\n```\r\nYou should add the `ngQuickGrid` and `quick-grid-partials` modules to your application.\r\n\r\n### Nuget\r\nTo add support to your .Net application install the nuget package.\r\n```\r\nInstall-Package QuickGrid\r\n```\r\n\r\n## Filters\r\n\r\n### Defining a filter\r\n\r\nYou define a filter on the model, typically in the controller hosting the grid.\r\n\r\n``` javascript\r\nmodel.search.addFilter('Company.Name', '%');\r\n```\r\n\r\nThat will add a filter targeting the Company.Name member expression. The `%` symbol indicates that this is a contains/like query. So if the value of the filter is `Acme` a linq expression will be applied as you had typed `queryable.Where(x => x.Company.Name.Contains(\"Acme\"))`.\r\n\r\n### Using a filter in your html\r\n\r\nThere is nothing fancy about using a filter in your markup. Just have the ng-model target the filter's value field.\r\n\r\n``` html\r\n<div class=\"col-lg-4\">\r\n  <div class=\"form-group\">\r\n    <label class=\"control-label\">Company Name</label>\r\n    <input type=\"text\" maxlength=\"200\" name=\"companyName\" ng-model=\"ctrl.model.search.filters['Company.Name'].value\" class=\"form-control\" autocomplete=\"off\" />\r\n  </div>\r\n</div>\r\n```\r\n\r\nRemember the grid will react immediately to any change to the filter model. You can control that to some extent by using `ng-model-options`.\r\n\r\n### Supported Filter Types\r\n\r\n|Operator|Name|Description|\r\n|---|---|---|\r\n|%|Contains|Matches any value that contains the filter value.|\r\n|~%|Stars With|Matches any value that starts with the filter value.|\r\n|%~|Ends With|Matches any value that ends with the filter value.|\r\n|()|Equals One Of|Matches any value that exactly matches one the values in a set. This creates an expression like: `query.Where(x => new [] {\"Cat\", \"Dog\"}.Contains(x.AnimalType))`. Best used with a multipicker such a `select multiple=\"multiple\"` element.|\r\n|=|Equals|Matches any value that exactly matches the filter value.|\r\n|>|Greater Than|Matches any value that is greater than the filter value. Works with dates and numbers.|\r\n|>=|Greater Than or Equal|Matches any value that is greater or equal to the filter value. Works with dates and numbers.|\r\n|<|Less Than|Matches any value that is less than the filter value. Works with dates and numbers.|\r\n|<=|Less Than or Equal|Matches any value that is less or equal to the filter value. Works with dates and numbers.|\r\n\r\n#### Not\r\n\r\nYou can return the inverse of the filter by calling `setNot(true|false)` on the filter. Or `toggleNot`. Eg: `model.search.filters['Company.Name'].setNot(true)`\r\n\r\n## Examples\r\n\r\nAdding markup for use in your angular application. Quick grid automatically re queries whenever the model or filters are changed and sets the page index back to zero. The _model_ is an arbitrary object; its members are sent to the server as part of the query request. Filters are structured query parameters that are automatically applied to the query and they are explained in more detail below.\r\n\r\n``` html\r\n<form name=\"form\" novalidate>\r\n  <div class=\"row\">\r\n    <div class=\"col-lg-4\">\r\n      <div class=\"form-group\">\r\n        <label class=\"control-label\">Order Type</label>\r\n        <select ng-model=\"ctrl.model.search.model.type\" name=\"orderType\" class=\"form-control\">\r\n          <option value=\"\">--</option>\r\n          <option value=\"Internal\">Internal</option>\r\n          <option value=\"External\">External</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n    <div class=\"col-lg-4\">\r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\">Company Name</label>\r\n          <input type=\"text\" maxlength=\"200\" name=\"companyName\" ng-model=\"ctrl.model.search.filters['Company.Name'].value\" class=\"form-control\" autocomplete=\"off\" />\r\n        </div>\r\n      </div>\r\n  </div>\r\n</form>\r\n```\r\n\r\nThis is an example table running on quick grid. Quick grid will handle sort clicks and re query the source while maintaining the current page index. The value of `quick-sort` just needs to be a valid member expression for the target class. Valid members are only those included in the projection and not the source object.\r\n\r\n``` html\r\n<table class=\"table table-hover\" quick-grid data-grid-model=\"ctrl.model.search\">\r\n  <thead>\r\n    <tr>\r\n      <th class=\"col-lg-2\" quick-sort=\"Type\">Order Type</th>\r\n      <th class=\"col-lg-2\" quick-sort=\"Company.Name\">Company</th>\r\n      <th class=\"col-lg-3\" quick-sort=\"Company.Type\">Type</th>\r\n      <th class=\"col-lg-1\" quick-sort=\"Amount\">Amount</th>\r\n      <th class=\"col-lg-2\" quick-sort=\"EmailAddress\">Email Address</th>\r\n      <th class=\"col-lg-2\" quick-sort=\"Status\">Status</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr ng-repeat=\"order in ctrl.model.results\">\r\n      <td>{{::order.type}}</td>\r\n      <td>{{::order.company.name}}</td>\r\n      <td>{{::order.company.type)}}</td>\r\n      <td>{{::order.amount}}</td>\r\n      <td>{{::order.emailAddress}}</td>\r\n      <td>{{::order.status}}</td>\r\n    </tr>\r\n  </tbody>\r\n  <tfoot>\r\n    <tr>\r\n      <td colspan=\"6\" class=\"text-center\" quick-paging></td>\r\n    </tr>\r\n  </tfoot>\r\n</table>\r\n```\r\n\r\nAngularJS example. This is an example controller that demonstrates creating a search model and binding it (`watch(scope)`) to the search model so it re queries when a change is made. You can instead of using watches, manually refresh the results to page 1 by calling `apply(true)` to execute the search query and return the paging to page 1 (sorting is not changed) or call `apply(false)` to execute the search query without changing the paging.\r\n\r\n``` js\r\nvar controller = ['SearchModel', '$scope', '$http',\r\n  function (SearchModel, $scope, $http) {\r\n    var model = {\r\n      search: new SearchModel(search, 'Status desc'),\r\n      results: null        \r\n    };\r\n\r\n    this.model = model;\r\n\r\n    function search (searchModel) {\r\n      return $http.get('/api/orders?' + searchModel.toQueryString(),)\r\n        .then(function (xhr) {\r\n          model.results = xhr.data.results;\r\n          return xhr.data;\r\n        })\r\n        .catch(console.error);\r\n    }\r\n\r\n    model.watch($scope);\r\n  }];\r\n```\r\n\r\nThe server side (csharp, webapi). This shows an example QueryOptions implementation. This example does not make use of filters, instead the properties are deserialized from the model sent from the client. How these are used is up the programmer, they have to manually apply them to the query.\r\n\r\n``` csharp\r\npublic class OrderListRequest : QueryOptions\r\n{\r\n    public OrderListRequest()\r\n        : base(20, \"Status desc\")\r\n    {\r\n    }\r\n\r\n    public OrderType? Type { get; set; }    \r\n}\r\n```\r\n\r\nThis is an example route that shows how to make use of a request.\r\n\r\n``` csharp\r\n[Route]\r\npublic IHttpActionResult Get([FromUri] OrderListRequest request)\r\n{\r\n    var source = _dbContext.Orders.AsQueryable();\r\n\r\n    if (request.Type.HasValue)\r\n    {\r\n        source = source.Where(x => x.Type == request.Type);\r\n    }\r\n\r\n    var query = source        \r\n        .Select(order => new\r\n        {\r\n            order.Id,\r\n            order.Type,\r\n            Company = new\r\n            {\r\n                order.Company.Name,\r\n                order.Company.Type\r\n            },\r\n            order.Amount\r\n            order.EmailAddress,\r\n            Status = order.Status.Name,\r\n            order.ModifiedUtcDate,            \r\n        });\r\n\r\n    var result = request.Apply(query);\r\n    return Ok(result);\r\n}\r\n```\r\n\r\nValues stored on your javascript search model (`search.model`) are moved up when transformed into json. There is `model` field in the json.\r\n\r\nSee you do not have to implement the `Company.Name` filter except to ensure that it can be resolved in the final select expression of your query.\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}